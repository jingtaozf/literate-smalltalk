# -*- encoding:utf-8 Mode: POLY-ORG; tab-width: 2; org-src-preserve-indentation: t; -*- ---
#+TITLE: Literate programming tool to write Smalltalk in org mode.
#+SubTitle: inspired by shampoo.
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+LATEX_HEADER: % copied from lstlang1.sty, to add new language support to Emacs Lisp.
#+LATEX_HEADER: \lstdefinelanguage{elisp}[]{lisp} {}
#+LATEX_HEADER: \lstloadlanguages{elisp}
#+PROPERTY: header-args
#+PROPERTY: literate-load yes
#+PROPERTY: literate-class LiterateServer
* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#preparation][Preparation]]
- [[#how-to-do-it-68][How to do it?]]
- [[#a-minor-mode-for-source-code][a minor mode for source code]]
  - [[#font-lock-keywords][font lock keywords]]
    - [[#binary-selectors][binary selectors]]
    - [[#basic-font-lock-keywords][basic font lock keywords]]
    - [[#level-1-smalltalk-font-locking-keywords][Level 1 Smalltalk font-locking keywords]]
    - [[#level-2-smalltalk-font-locking-keywords][Level 2 Smalltalk font-locking keywords]]
    - [[#font-lock-keywords-list][font lock keywords list]]
  - [[#syntax-table][syntax table]]
  - [[#mode-definition][mode definition]]
  - [[#add-to-auto-mode-alist][add to auto mode alist]]
- [[#utilities][utilities]]
  - [[#encode-string][encode string]]
  - [[#decode-string][decode string]]
  - [[#select-helm-marked-candidates][select helm marked candidates]]
  - [[#forward-to-begin-of-function][forward to begin of function]]
  - [[#region-of-current-symbol][region of current symbol]]
  - [[#current-symbol-at-point][current symbol at point]]
  - [[#previous-symbol-at-point][previous symbol at point]]
  - [[#check-autogenerated-code][check autogenerated code]]
  - [[#get-selector-from-a-line-of-code][get selector from a line of code]]
  - [[#api-request][api request]]
- [[#baseline-for-pharo][baseline for pharo]]
  - [[#definition][definition]]
  - [[#spec][spec]]
- [[#a-teapot-server-to-handle-request][a Teapot server to handle request]]
  - [[#definition-1][definition]]
  - [[#the-server-accessor][the Server accessor]]
    - [[#reader][reader]]
    - [[#writer][writer]]
  - [[#dispatch-requests-to-api-method][dispatch requests to api method]]
  - [[#start][start]]
  - [[#log-messages-in-transcript][log messages in Transcript]]
    - [[#emacs][Emacs]]
    - [[#pharo][Pharo]]
  - [[#utils][utils]]
    - [[#asstringarray][asStringArray:]]
    - [[#elementsstring][elementsString]]
    - [[#abort-current-reqeust][abort current reqeust]]
    - [[#bringtofront][bringToFront]]
    - [[#release-an-iceberg-package-to-local-file-system][release an Iceberg package to local file system.]]
- [[#query][Query]]
  - [[#namespace][namespace]]
    - [[#namespaces][namespaces]]
    - [[#classes-for-one-namespace][classes for one namespace]]
  - [[#package][package]]
    - [[#a-list-of-all-packages][a list of all packages]]
    - [[#a-list-of-package-tags][a list of package tags.]]
    - [[#a-list-of-classes-for-a-package-tag][a list of classes for a package tag]]
    - [[#a-list-of-package-extensions][a list of package extensions.]]
  - [[#class][class]]
    - [[#emacs-1][Emacs]]
    - [[#pharo-1][Pharo]]
- [[#compile][Compile]]
  - [[#eval-code][eval code]]
    - [[#emacs-2][Emacs]]
    - [[#pharo-2][Pharo]]
  - [[#compile-1][compile]]
    - [[#emacs-3][Emacs]]
    - [[#command-to-code-format][command to code format]]
    - [[#command-to-delete-a-class-method][command to delete a class method]]
    - [[#code-completion-with-company-mode][code completion with company mode]]
    - [[#pharo-3][Pharo]]
- [[#code-navigation][Code navigation]]
  - [[#search-a-pattern-in-a-buffer-and-return-its-position][search a pattern in a buffer and return its position]]
  - [[#find-definition-of-class-in-org-files][find definition of class in org files]]
  - [[#find-definition-of-a-class-method-in-org-files][find definition of a class method in org files]]
  - [[#get-method-name-from-method-codes][get method name from method codes]]
  - [[#basic-idea][basic idea]]
  - [[#xref-interfaces][xref interfaces]]
  - [[#implementation][implementation]]
  - [[#browse-class-in-pharo][browse class in Pharo]]
    - [[#emacs-4][Emacs]]
    - [[#pharo-4][Pharo]]
  - [[#browse-implementors-in-pharo][browse implementors in Pharo]]
    - [[#emacs-5][Emacs]]
    - [[#pharo-5][Pharo]]
- [[#update-source][Update source]]
- [[#imports-codes-to-org-file][imports codes to org file]]
  - [[#import-codes-of-namespaces-to-org-mode][Import codes of namespaces to org mode]]
  - [[#import-codes-of-packages-to-org-mode][Import codes of packages to org mode]]
- [[#babel-support][babel support]]
  - [[#optionally-define-a-file-extension-for-this-language][optionally define a file extension for this language]]
  - [[#optionally-declare-default-header-arguments][optionally declare default header arguments]]
  - [[#source-code-execution][Source Code Execution]]
    - [[#babel-entry][babel entry]]
    - [[#implementation-1][implementation]]
  - [[#execute-all-source-codes-in-current-header][execute all source codes in current header]]
  - [[#execute-source-codes-in-current-code-block][execute source codes in current code block]]
- [[#release-from-pharo-to-local-file-system][Release from pharo to local file system]]
- [[#test][Test]]
  - [[#eval-codes][eval codes]]
  - [[#ban-some-critiques-rules][ban some critiques rules]]
  - [[#test-1][test]]

* Introduction
This is an attemp to write smalltalk codes in org mode,
and interact with remote [[https://pharo.org/][pharo]] images inspired from [[https://github.com/dmatveev/shampoo-emacs][shampoo]]([[https://github.com/jingtaozf/shampoo-pharo.git][shampo for pharo]]).
* Preparation
You need to install pharo side codes in pharo and start server by the following codes
#+begin_src st
LiterateServer start.
#+end_src
* How to do it? [6/8]

We setup a HTTP server in Pharo, so Emacs can interact with Pharo to
- fetch packages, classes, method source
- compile class/methods
- format code block
- show suggestions, etc.


- [X] Find packages's sub category
  https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Extensions.md#define-an-extension-method-programmatically
- [X] Find package's extensions
  (RPackageOrganizer default packageMatchingExtensionName: #packagename) metaclassExtensionSelectors .
- [X] Tonel read write
  https://gist.github.com/peteruhnak/e4ba8d52bf4a89c4c9e015bb59b442fd
- [X] opal compile
	https://gist.github.com/peteruhnak/e2235e43a25feb6cf0d7196192cf8aea
- [X] remove a class method at point
  MyClass removeFromSystem
  MyClass removeSelector: #foo
- [ ] raise pharo window when any exception
- [ ] rename class methods
	https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/CoolSnippets.md#rename-programatically-methods
- [X] playground/REPL in Emacs
  StPlaygroundInteractionModel
* a minor mode for source code
:PROPERTIES:
:literate-lang: elisp
:END:
inspired from shampoo-code-mode
** font lock keywords
*** binary selectors
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-binsel "\\([-+*/~,<>=&?]\\{1,2\\}\\|:=\\|||\\)"
"Smalltalk binary selectors")
#+END_SRC
*** basic font lock keywords
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords
(list
'("#[A-z][A-z0-9_]*"          . font-lock-constant-face)
'("\\<[A-z][A-z0-9_]*:"       . font-lock-function-name-face)
(cons literate-smalltalk-smalltalk-binsel 'font-lock-function-name-face)
'("\\$."                      . font-lock-string-face)
'("\\<[A-Z]\\sw*\\>"          . font-lock-type-face)
'("[0-9]+"                    . font-lock-constant-face))
"Basic Smalltalk keywords font-locking")
#+END_SRC
*** Level 1 Smalltalk font-locking keywords
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords-1
literate-smalltalk-smalltalk-font-lock-keywords
"Level 1 Smalltalk font-locking keywords")
#+END_SRC

*** Level 2 Smalltalk font-locking keywords
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords-2
(append literate-smalltalk-smalltalk-font-lock-keywords-1
(list
		'("\\<\\(true\\|false\\|nil\\|self\\|super\\)\\>"
		. font-lock-builtin-face)
		'(":[a-z][A-z0-9_]*" . font-lock-variable-name-face)
		'(" |"               . font-lock-type-face)
		'("<.*>"             . font-lock-builtin-face)))
"Level 2 Smalltalk font-locking keywords")
#+END_SRC
*** font lock keywords list
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords-list
'((literate-smalltalk-smalltalk-font-lock-keywords
		literate-smalltalk-smalltalk-font-lock-keywords-1
		literate-smalltalk-smalltalk-font-lock-keywords-2)))
#+END_SRC
** syntax table
#+BEGIN_SRC elisp
(defvar literate-smalltalk-smalltalk-mode-syntax-table
    (let ((table (make-syntax-table)))
      ;; Make sure A-z0-9 are set to "w   " for completeness
      (let ((c 0))
		    (setq c ?0)
		    (while (<= c ?9)
          (setq c (1+ c))
          (modify-syntax-entry c "w   " table))
		    (setq c ?A)
		    (while (<= c ?Z)
          (setq c (1+ c))
          (modify-syntax-entry c "w   " table))
		    (setq c ?a)
		    (while (<= c ?z)
          (setq c (1+ c))
          (modify-syntax-entry c "w   " table)))
      (modify-syntax-entry 10  " >  " table) ; Comment (generic)
      (modify-syntax-entry ?:  ".   " table) ; Symbol-char
      (modify-syntax-entry ?_  "_   " table) ; Symbol-char
      (modify-syntax-entry ?\" "!1  " table) ; Comment (generic)
      (modify-syntax-entry ?'  "\"  " table) ; String
      (modify-syntax-entry ?#  "'   " table) ; Symbol or Array constant
      (modify-syntax-entry ?\( "()  " table) ; Grouping
      (modify-syntax-entry ?\) ")(  " table) ; Grouping
      (modify-syntax-entry ?\[ "(]  " table) ; Block-open
      (modify-syntax-entry ?\] ")[  " table) ; Block-close
      (modify-syntax-entry ?{  "(}  " table) ; Array-open
      (modify-syntax-entry ?}  "){  " table) ; Array-close
      ;; (modify-syntax-entry ?$  "/   " table) ; Character literal
      (modify-syntax-entry ?!  ".   " table) ; End message / Delimit defs
      (modify-syntax-entry ?\; ".   " table) ; Cascade
      (modify-syntax-entry ?|  ".   " table) ; Temporaries
      (modify-syntax-entry ?^  ".   " table) ; Return
      ;; Just to make sure these are not set to "w   "
      (modify-syntax-entry ?<  ".   " table)
      (modify-syntax-entry ?>  ".   " table)
      (modify-syntax-entry ?+  ".   " table) ; math
      (modify-syntax-entry ?-  ".   " table) ; math
      (modify-syntax-entry ?*  ".   " table) ; math
      (modify-syntax-entry ?/  ".2  " table) ; math
      (modify-syntax-entry ?=  ".   " table) ; bool/assign
      (modify-syntax-entry ?%  ".   " table) ; valid selector
      (modify-syntax-entry ?&  ".   " table) ; boolean
      (modify-syntax-entry ?\\ ".   " table) ; ???
      (modify-syntax-entry ?~  ".   " table) ; misc. selector
      (modify-syntax-entry ?@  ".   " table) ; Point
      (modify-syntax-entry ?,  ".   " table) ; concat
      table)
  "Syntax table used by Smalltalk mode")
#+END_SRC

** mode definition
#+BEGIN_SRC elisp
(define-derived-mode literate-smalltalk-code-mode
    text-mode "Literate Smalltalk code"
    (set (make-local-variable 'font-lock-defaults)
				 literate-smalltalk-smalltalk-font-lock-keywords-list)
    (set (make-local-variable 'comment-start) "\"")
    (set (make-local-variable 'comment-end) "\"")
    (set (make-local-variable 'case-fold-search) nil)
    (set-syntax-table literate-smalltalk-smalltalk-mode-syntax-table))
#+END_SRC
** add to auto mode alist
#+BEGIN_SRC elisp
(setq auto-mode-alist (append '(("\\.st\\'" . literate-smalltalk-code-mode)) auto-mode-alist))
#+END_SRC
* utilities
** encode string
#+BEGIN_SRC elisp
(cl-defun literate-smalltalk-encode-string (code &key unquote-string)
  (encode-coding-string
   (if unquote-string
     (replace-regexp-in-string "''" "'" code)
     code)
   'latin-1-mac))
#+END_SRC
** decode string
#+BEGIN_SRC elisp
(cl-defun literate-smalltalk-decode-string (code &key quote-string)
  (decode-coding-string
   (if quote-string
     (replace-regexp-in-string "'" "''" code)
     code)
   'latin-1-mac))
#+END_SRC

** select helm marked candidates
#+BEGIN_SRC elisp
(defun literate-smalltalk-helm-select-list (prompt list)
  (let* ((list (typecase list
                 (vector (mapcar 'identity list))
                 (t list)))
         (helm-selected-value nil)
         (helm-source
           `((name . ,prompt)
             (candidates . ,list)
             (action . (lambda (candidate)
                         (setf helm-selected-value
                                 (helm-marked-candidates)))))))
    (helm :sources '(helm-source) :prompt prompt)
    helm-selected-value))
#+END_SRC

** forward to begin of function
#+BEGIN_SRC elisp
(defun literate-smalltalk-beginning-of-defun-function (arg)
  (if (> arg 0)
    (progn
      (search-backward "#+BEGIN_SRC ")
      (forward-line))
    (literate-smalltalk-end-of-defun-function)))

(defun literate-smalltalk-end-of-defun-function (arg)
  (search-forward "#+END_SRC")
  (forward-line -1))

(defun install-literate-smalltalk-beginning-of-defun-function ()
  (make-local-variable 'beginning-of-defun-function)
  (make-local-variable 'end-of-defun-function)
  (setf beginning-of-defun-function 'literate-smalltalk-beginning-of-defun-function)
  (setf end-of-defun-function 'literate-smalltalk-end-of-defun-function)
  )
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-beginning-of-defun-function)
#+END_SRC
** region of current symbol
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-region ()
  (save-excursion
    (let* ((beg (re-search-backward "[ \t\n\r(^[]" nil t))
           (end (progn
                  (forward-char)
                  (re-search-forward "[ \t\n\r\.]" nil t)
                  (backward-char)
                  (point))))
      (cons beg end))))
#+END_SRC

** current symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-at-point ()
  (let* ((region (literate-smalltalk-current-symbol-region))
         (beg (car region))
         (end (cdr region)))
    (string-trim (buffer-substring-no-properties beg end) "[ \t\n\r(^]+")))
#+END_SRC
** previous symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-previous-symbol-at-point ()
  (save-excursion
    (re-search-backward "[ \t\n\r]" nil t)
    (forward-word -1)
    (literate-smalltalk-current-symbol-at-point)))
#+END_SRC
** check autogenerated code
#+BEGIN_SRC elisp
(defvar literate-smalltalk-autogenerated-code-patterns nil)
(defun literate-smalltalk-autogenerated-code? (code)
  (loop for pattern in literate-smalltalk-autogenerated-code-patterns
        thereis (funcall pattern code)))
#+END_SRC
** get selector from a line of code
#+BEGIN_SRC elisp
(defun literate-smalltalk-extract-selector (line)
  (let ((parts (split-string line)))
    (if (= 1 (length parts))
      (car parts)
      (apply 'concat (loop for part in parts
                          if (search ":" part)
                            collect part)))))
#+END_SRC

** api request
#+BEGIN_SRC elisp
(defvar literate-smalltalk-rest-server "http://localhost:9092/")
(defvar literate-smalltalk-last-response nil)
(cl-defun literate-smalltalk-request (path &key params data (type "GET"))
  (setf literate-smalltalk-last-response nil)
  (let ((request-backend 'url-retrieve))
    (request (concat literate-smalltalk-rest-server path)
        :params params
        :parser 'json-read
        :type type
        :sync t
        :data data
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-smalltalk-last-response response)
                     (case (request-response-status-code response)
                       (200 (setf resp (request-response-data response)))
                       (500 (user-error "Pharo failed:%s" (cdr (assoc 'message resp))))
                       (t (user-error "Failed to request to remote pharo:%s" response)))))))
  (request-response-data literate-smalltalk-last-response))
#+END_SRC
* baseline for pharo
:PROPERTIES:
:literate-class: BaselineOfLiterateSmalltalk
:END:
** definition
#+BEGIN_SRC smalltalk
BaselineOf subclass: #BaselineOfLiterateSmalltalk
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'BaselineOfLiterateSmalltalk'.
BaselineOfLiterateSmalltalk class
    instanceVariableNames: ''.
BaselineOfLiterateSmalltalk comment: 'Baseline of LiterateSmalltalk.'
#+END_SRC
** spec
#+BEGIN_SRC smalltalk :cat "baseline" :side instance
baselineOf: spec

	<baseline>
	spec for: #common do: [
		spec
			baseline: 'Teapot' with: [
				spec
					repository: 'github://zeroflag/Teapot:v2.6.0/source';
					loads: #( 'Deployment' ) ];
			import: 'Teapot'.
		spec
			package: 'LiterateSmalltalk'
			with: [ spec requires: #( 'Teapot' ) ].
		spec group: 'default' with: #( 'LiterateSmalltalk' ) ]
#+END_SRC
* a Teapot server to handle request
** definition
#+BEGIN_SRC smalltalk
Object subclass: #LiterateServer
    instanceVariableNames: ''
    classVariableNames: 'Server Started interactionModel transcriptLogStream'
    package: 'LiterateSmalltalk'.
LiterateServer class
    instanceVariableNames: ''.
LiterateServer comment: 'The REST Server for LiterateSmalltalk.'
#+END_SRC
** the Server accessor
*** reader
#+BEGIN_SRC smalltalk :side class :cat "accessing"
server
	"returns teapot instance"
	^ Server
#+END_SRC
*** writer
#+BEGIN_SRC smalltalk :side class :cat "accessing"
server: server
	"sets teapot for class"
	Server := server.
#+END_SRC
** dispatch requests to api method
The dispatch rule is simple: if the incoming request contains a parameter =api=, we will
try to perform request on class method with prefix =api= and the value of this parameter.
#+BEGIN_SRC smalltalk :side class :cat "management"
dispatch: req

	| apiName methodName |
	apiName := req
		           at: #api
		           ifAbsent: [ self abortReq: req status: 'fatal' message: 'No api specified.' ].
	methodName := ('api' , apiName , ':') asSymbol.
	(self class canUnderstand: methodName) ifFalse: [
		self abortReq: req status: 'fatal' message: 'No implementation for this api' ].
	^ self perform: methodName with: req
#+END_SRC
** start
#+BEGIN_SRC smalltalk :side class :cat "management"
start

	"Start the webserver"

	| teapot |
	"extra check so that we don't close a Pool which wasn't open"
	Started ifNotNil: [ Server stop ].
	Transcript addDependent: self.
	teapot := Teapot configure: {
			          (#defaultOutput -> #json).
			          (#port -> 9092).
			          (#debugMode -> true).
			          (#bindAddress -> #[ 127 0 0 1 ]) }.
	teapot server logLevel: 1.
	self server: teapot.
	teapot
		addRouteMethod: TeaMethodMatcher any
		pattern: '/api/<api>/*'
		action: [ :req | self dispatch: req ];
		output: #json;
		exception: Exception -> [ :ex :req |
				Transcript
					show: 'bring pharo to front because of ';
					show: ex asString;
					cr.
				self bringToFront.
				ex pass.
				ZnResponse serverError: (NeoJSONWriter toString: {
							 (#status -> #fatal).
							 (#message -> ex asString) } asDictionary) ];
		start.
	interactionModel := StPlaygroundInteractionModel new owner: StPlaygroundPagePresenter new.
	Started := true
#+END_SRC
** log messages in Transcript
We will just output it to a log file, and can monitor them in a Emacs buffer.
*** Emacs
#+BEGIN_SRC elisp
(defvar literate-smalltalk-transcript-log-file "~/.cache/literate-smalltalk/transcript.log")
(make-directory (file-name-directory literate-smalltalk-transcript-log-file) t)
#+END_SRC

*** Pharo
An interface to update of Transcript.
#+BEGIN_SRC smalltalk :side class :cat updating
update: aChange

	aChange = #appendEntry ifFalse: [ ^ self ].
	transcriptLogStream ifNotNil: [
		transcriptLogStream closed ifTrue: [ transcriptLogStream := nil ] ].
	transcriptLogStream ifNil: [
		transcriptLogStream := ((OSEnvironment current at: 'HOME')
		                        , '/.cache/literate-smalltalk/transcript.log') asFileReference
			                       writeStream.
		transcriptLogStream setToEnd ].
	transcriptLogStream print: Transcript contents.
	transcriptLogStream flush
#+END_SRC
** utils
*** asStringArray:
Many reflection methods return different results in various dialects.
=#instVarNames= in GNU Smalltalk returns an IdentitySet of Symbols, the
same method returns an Array of Strings in Squeak

This kludge works as an abstraction over it all
#+BEGIN_SRC smalltalk :side class :cat "utilities"
asStringArray: items

	^ (items collect: [ :each | each asString ]) asArray
#+END_SRC
*** elementsString
#+BEGIN_SRC smalltalk :side class :cat "utilities"
elementsString: items

	^ items inject: '' into: [ :acc :each | acc , each asString , ' ' ]
#+END_SRC
*** abort current reqeust
#+BEGIN_SRC smalltalk :side class :cat "utilities"
abortReq: req status: status message: message

	req abort: {
			('status' -> status).
			('message' -> message) } asDictionary
#+END_SRC
*** bringToFront
#+BEGIN_SRC smalltalk :side class :cat "utilities"
bringToFront

	"a way to bring pharo window to front"
	LibC uniqueInstance system: 'xdotool search --name ''Pharo'' windowactivate'
#+END_SRC
*** release an Iceberg package to local file system.
#+BEGIN_SRC smalltalk :side class :cat "utilities"
releaseIcebergPackage: icebergPackage

	| iceRepository location srcDirectory |
	iceRepository := IceRepository registeredRepositoryIncludingPackage:
		                 (RPackageOrganizer default packageNamed: icebergPackage).
	location := iceRepository location.
	srcDirectory := iceRepository project properties at: 'srcDirectory' ifAbsent: ''.
	srcDirectory ifNotEmpty: [ location := location / srcDirectory ].
	iceRepository workingCopy packages do: [ :package |
		| packageName |
		packageName := package package.
		(RPackageOrganizer default packageNamed: packageName asSymbol) classTags do: [ :tag |
			tag orderedClasses do: [ :class |
				| file |
				file := location / ('{1}/{2}.class.st' format: {
						         packageName.
						         class asString }).
				file exists ifTrue: [ file delete ].
				file
					writeStreamDo: [ :s | TonelWriter exportClass: class on: s ];
					yourself ] ] ]
#+END_SRC
* Query
** namespace
*** namespaces
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespaces ()
  (cdr (assoc 'namespaces (literate-smalltalk-request "api/Namespaces"))))

(defun literate-smalltalk-select-namespace ()
  (literate-smalltalk-helm-select-list "namespace" (literate-smalltalk-namespaces)))
#+END_SRC
**** pharo
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiNamespaces: req

	| names |
	names := (Smalltalk globals allClasses collect: [ :each | each category asString ]) asSet
		         asSortedCollection.
	^ {
		  (#status -> #success).
		  (#namespaces -> names) } asDictionary
#+END_SRC
**** cache relationship between namespace and class
It is slow to build such indexed from remote pharo, let store it to a global variable and cache it to local file.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-indexed-classes-file "~/.emacs.d/smalltalk.classes.txt")
(defvar literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
(defun literate-smalltalk-index-classes ()
  (interactive)
  (loop for namespace in (literate-smalltalk-namespaces)
        do (message "Indexing %s" namespace)
           (loop for class in (literate-smalltalk-classes namespace)
                 do (setf (gethash class literate-smalltalk-indexed-classes) namespace)))
  (with-current-buffer (find-file-noselect literate-smalltalk-indexed-classes-file)
    (erase-buffer)
    (fundamental-mode)
    (maphash (lambda (k v)
               (insert k " " v "\n"))
             literate-smalltalk-indexed-classes)
    (save-buffer)
    (kill-current-buffer)))

(defun literate-smalltalk-restore-indexed-classes ()
  (interactive)
  (message "start restoring...")
  (setf literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
  (cl-loop for line in (s-split "\n" (f-read literate-smalltalk-indexed-classes-file) t)
           for items = (s-split " " line)
           do (setf (gethash (car items) literate-smalltalk-indexed-classes) (second items)))
  (message "restoring...done"))
#+END_SRC
**** get namespace of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-of-a-class (class)
  (when (= 0 (hash-table-count literate-smalltalk-indexed-classes))
    (user-error "Please build the cache before use namespace of a class."))
  (gethash class literate-smalltalk-indexed-classes))

(defun literate-smalltalk-namespace-of-current-symbol ()
  (interactive)
  (let ((class (thing-at-point 'symbol)))
    (message "%s's namespace is %s" class (literate-smalltalk-namespace-of-a-class class))))
#+END_SRC
*** classes for one namespace
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-classes (namespace)
  (mapcar 'identity
          (cdr (assoc 'classes (literate-smalltalk-request "api/Classes"
                                                           :params `(("namespace" . ,namespace)))))))

(defun literate-smalltalk-select-a-class (namespace)
  (literate-smalltalk-helm-select-list "Please select a namespace: " (literate-smalltalk-classes namespace)))
#+END_SRC
**** Pharo
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiClasses: req

	| namespace resultList |
	namespace := req at: #namespace.
	resultList := Smalltalk globals allClasses select: [ :each |
		              each category asString = namespace ].
	^ {
		  (#status -> #success).
		  #classes -> (resultList collect: [ :each | each name asString ])  } asDictionary
#+END_SRC
** package
This bases on [[https://github.com/pharo-project/pharo/blob/Pharo9.0/src/RPackage-Core/RPackage.class.st][RPakcage]].
*** a list of all packages
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-packages ()
  (cdr (assoc 'packages (literate-smalltalk-request "api/Packages"))))

(defun literate-smalltalk-select-package ()
  (literate-smalltalk-helm-select-list "Please select a package: " (literate-smalltalk-packages)))
#+END_SRC
**** pharo
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiPackages: req

	^ {
		  (#status -> #success).
		  (#packages -> RPackageOrganizer default packageNames) } asDictionary
#+END_SRC
*** a list of package tags.
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-package-tags (package)
  (cdr (assoc 'tags (literate-smalltalk-request "api/PackageTags"
                                                :params `(("package" . ,package))))))

(defun literate-smalltalk-select-package-tag (package)
  (literate-smalltalk-helm-select-list "Please select a package tag: " (literate-smalltalk-package-tags package)))
#+END_SRC
**** pharo
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiPackageTags: req

	| packageName package tags |
	packageName := req at: #package.
	package := RPackageOrganizer default
		           packageNamed: packageName asSymbol
		           ifAbsent: RPackage new.
	tags := (package classTags collect: [ :tag |
		         {
			         (#name -> tag name asString).
			         (#classes -> (tag orderedClasses collect: [ :each | each asString ])) }
			         asDictionary ]) sorted: [ :item | item at: #name ] ascending.
	^ {
		  (#status -> #success).
		  (#tags -> tags) } asDictionary
#+END_SRC
*** a list of classes for a package tag
*** a list of package extensions.
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-package-extensions (package)
  (cdr (assoc 'methods (literate-smalltalk-request "api/PackageExtensions" :params `(("package" . ,package))))))

(defun literate-smalltalk-select-package-extension (package)
  (literate-smalltalk-helm-select-list "Please select a package extension: " (literate-smalltalk-package-extensions package)))
#+END_SRC

**** pharo
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiPackageExtensions: req

	| packageName package methods |
	packageName := req at: #package.
	package := RPackageOrganizer default
		           packageNamed: packageName asSymbol
		           ifAbsent: RPackage new.
	methods := package extensionMethods collect: [ :each |
		           | class side |
		           class := each methodClass.
		           side := #instance.
		           (class isKindOf: Metaclass) ifTrue: [
			           side := #class.
			           class := class instanceSide ].
		           {
			           (#name -> each name).
			           (#selector -> each selector).
			           (#category -> each category).
			           (#side -> side).
			           (#code -> each sourceCode).
			           (#class -> class asString) } asDictionary ].
	^ {
		  (#status -> #success).
		  (#methods -> methods) } asDictionary
#+END_SRC
** class
*** Emacs
**** print out class definition
#+BEGIN_SRC elisp
(defconst literate-smalltalk-class-template
  '(("instanceVariableNames:" . instvars)
    ("classVariableNames:"    . classvars)
    ;; ("poolDictionaries:"      . poolvars)
    ))

(defconst literate-smalltalk-class-side-template
  '(("instanceVariableNames:" . instvars)))
(defvar literate-smalltalk-separator "----------------------")

(defun literate-smalltalk-class-definition-string (resp)
  (let ((instance (cdr (assoc 'instance resp)))
        (class (cdr (assoc 'class resp))))
    (with-temp-buffer
      (insert
       (format "%s subclass: #%s"
               (cdr (assoc 'superclass instance))
               (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (insert (format
               "    package: '%s'."
               (cdr (assoc 'package instance))))
      (newline)

      (insert (format "%s class" (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-side-template)
        (let* ((items (cdr (assoc (cdr each) class)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'."  (car each) text))
          (newline)))
      (insert (format "%s comment: '%s'" (cdr (assoc 'class class))
                      (literate-smalltalk-decode-string (cdr (assoc 'comment instance)) :quote-string t)))
      (trim-string (buffer-string)))))
#+END_SRC
**** get class definition
#+BEGIN_SRC elisp
(defun literate-smalltalk-class (class)
  (literate-smalltalk-class-definition-string (cdr (assoc 'result (literate-smalltalk-request "api/ClassDef"
                                                                                              :params `(("class" . ,class)))))))
#+END_SRC
**** get categories of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-categories (class)
  (cdr (assoc 'result (literate-smalltalk-request "api/ClassCats" :params `(("class" . ,class))))))
#+END_SRC
**** get methods of one category
#+BEGIN_SRC elisp
(defun literate-smalltalk-category-methods (class category side)
  (mapcar 'identity
          (cdr (assoc 'methods (literate-smalltalk-request "api/CatMethods"
                                                           :params `(("class" . ,class)
                                                                     ("cat" . ,category)
                                                                     ("side" . ,side)))))))
#+END_SRC
**** get method source
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-source (class method side)
  (unless class
    (user-error "Please specifiy the class of current method!"))
  (unless side
    (user-error "Please specifiy the side of current method!"))
  (let* ((resp (literate-smalltalk-request
                "api/MethodSource"
                :params `(("class" . ,class)
                          ("name" . ,method)
                          ("side" . ,side))))
         (source (cdr (assoc 'source resp))))
    (literate-smalltalk-decode-string source)))
#+END_SRC
*** Pharo
**** class definition
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiClassDef: req

	| className class instanceSide classSide result |
	className := req at: #class.
	class := Smalltalk at: className asSymbol.
	instanceSide := Dictionary new.
	instanceSide at: #class put: className.
	instanceSide at: #superclass put: class superclass printString.
	instanceSide at: #instvars put: (self asStringArray: class instVarNames).
	instanceSide at: #classvars put: (self asStringArray: class classVarNames).
	instanceSide at: #poolvars put: (self asStringArray: class sharedPools).
	instanceSide at: #package put: class category.
	instanceSide at: #comment put: class comment.

	class := class class.
	classSide := Dictionary new.
	classSide at: #class put: className.
	classSide at: #superclass put: class superclass printString.
	classSide at: #instvars put: (self asStringArray: class instVarNames).
	classSide at: #classvars put: (self asStringArray: class classVarNames).
	classSide at: #poolvars put: (self asStringArray: class sharedPools).
	result := Dictionary new.
	result at: #instance put: instanceSide.
	result at: #class put: classSide.
	^ {
		  (#status -> #success).
		  (#result -> result) } asDictionary
#+END_SRC
**** get class categories
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiClassCats: req

	| className class cats result |
	className := req at: #class.
	result := Dictionary new.
	class := Smalltalk at: className asSymbol.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d | d valuesDo: [ :each | cats add: each category ] ].

	result at: #instance put: cats.

	class := class class.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d | d valuesDo: [ :each | cats add: each category ] ].
	result at: #class put: cats.
	^ {
		  (#status -> #success).
		  (#result -> result) } asDictionary
#+END_SRC
**** get methods in one class category
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiCatMethods: req

	| className cat side class methods allMethods |
	className := req at: #class.
	cat := req at: #cat.
	side := req at: #side.
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	allMethods := class methodDictionary ifNil: [ #(  ) ] ifNotNil: [ :x | x associations ].

	methods := cat = '*'
		           ifTrue: [ allMethods ]
		           ifFalse: [ allMethods select: [ :e | e value category = cat ] ].
	^ {
		  (#status -> #success).
		  (#methods -> (methods collect: [ :each | each key asString ]) asSortedCollection) }
		  asDictionary
#+END_SRC
**** get method source
#+BEGIN_SRC smalltalk :side class :cat "query api"
apiMethodSource: req

	| className methodName side class method |
	className := req at: #class.
	methodName := req at: #name.
	side := req at: #side.
	class := Smalltalk at: className asSymbol.
	class := side = #class
		         ifTrue: [ class class ]
		         ifFalse: [ class ].
	method := class methodDictionary at: methodName asSymbol.
	^ {
		  (#status -> #success).
		  (#source -> method sourceCode) } asDictionary
#+END_SRC
* Compile
** eval code
*** Emacs
**** eval
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval (code inspector-p)
  (let ((resp (literate-smalltalk-request
               "api/EvalCode"
               :type "POST"
               :data `(("code" . ,code)
                       ("inspector" . ,(if inspector-p
                                         "true"
                                         "false"))))))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'message resp))
      (user-error "Failed to eval code:'%s'!" (cdr (assoc 'message resp))))))
#+END_SRC
**** local bindings
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval-bindings ()
  (interactive)
  (let ((resp (literate-smalltalk-request "api/EvalBindings")))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'message resp))
      (user-error "Failed to list bindings:'%s'!" (cdr (assoc 'message resp))))))
#+END_SRC
**** eval current line or selected region
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval-current-line-or-selected-region ()
  (interactive)
  (let ((code (if (region-active-p)
                (buffer-substring-no-properties (region-beginning) (region-end))
                (buffer-substring-no-properties (line-beginning-position) (line-end-position)))))
    (message (literate-smalltalk-eval code (not (null current-prefix-arg))))))
#+END_SRC

*** Pharo
**** eval a code text
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiEvalCode: req

	| code openInspector status result receiver evaluationContext |
	code := req at: #code.
	openInspector := (req at: #inspector ifAbsent: 'false') = 'true'.
	status := #success.
	receiver := interactionModel doItReceiver.
	evaluationContext := interactionModel doItContext.
	result := receiver class compiler
		          source: code;
		          context: evaluationContext;
		          receiver: receiver;
		          requestor: nil; "As it is a remote request, we allow compiler handle messages such as exceptions"
		          failBlock: [ ^ nil ];
		          evaluate.

	openInspector ifTrue: [
		self bringToFront.
		GTInspector inspect: result ].
	^ {
		  (#message -> result asString).
		  (#status -> status) } asDictionary
#+END_SRC
**** list bindings of all evaluated codes.
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiEvalBindings: req

	self bringToFront.
	GTInspector inspect: interactionModel bindings.
	^ {
		  (#status -> #success).
		  (#message -> 'Inspector has been opened.') } asDictionary
#+END_SRC
** compile
*** Emacs
**** compile class
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-class (code)
  (let ((resp (literate-smalltalk-request
               "api/CompileClass"
               :data `(("code" . ,(literate-smalltalk-encode-string code)))
               :type "POST")))
    (message "Compile class %s." (cdr (assoc 'status resp)))))
#+END_SRC
**** compile method
#+BEGIN_SRC elisp
(defface literate-smalltalk-correction-face
    '((((class mono)) (:inverse-video t :bold t :underline t))
      (t (:background "LightPink4" :bold t)))
  "Face used to visualize correction."
  :group 'literate-smalltalk)

(defun literate-smalltalk-compile-method (class side category code block-info)
  (unless class
    (user-error "Please specifiy the class of current method!"))
  (unless side
    (user-error "Please specifiy the side of current method!"))
  (unless category
    (user-error "Please specifiy the category of current method!"))
  (let* ((resp (literate-smalltalk-request
                "api/CompileMethod"
                :data `(("class" . ,class)
                          ("category" . ,category)
                          ("source" . ,code)
                          ("side" . ,side))
                :type "POST"))
         (result (cdr (assoc 'status resp)))
         (message (or (cdr (assoc 'message resp)) ""))
         (critiques (cdr (assoc 'critiques resp)))
         (begin (save-excursion
                  (goto-char (plist-get block-info :begin))
                  (forward-line)
                  (line-beginning-position)))
         (selector-end-position
           (save-excursion
             (goto-char (plist-get block-info :begin))
             (forward-line)
             (line-end-position)))
         (end (save-excursion
                  (goto-char (plist-get block-info :end))
                  (forward-line -1)
                  (line-end-position)))
         (overlay-in-first-line nil))
    (save-excursion
      (goto-char begin)
      (pm-set-buffer (point))
      (mapcar (lambda (ov)
                (when (overlay-get ov 'smalltalk-message)
                  (delete-overlay ov)))
              (overlays-in begin end))
      (mapcar (lambda (critique)
                ;; there may have multiple critiques for a method without range, we all put them in first line.
                (let* ((original-message nil)
                       (ov (if (and (cdr (assoc 'first critique))
                                    (null (overlays-in begin selector-end-position)))
                             (make-overlay (+ begin (cdr (assoc 'first critique)))
                                           (+ begin (cdr (assoc 'last critique))))
                             (if overlay-in-first-line
                               (prog1 overlay-in-first-line
                                      (setf original-message
                                              (concat (overlay-get overlay-in-first-line 'smalltalk-message) "\n")))
                               (setf overlay-in-first-line (make-overlay begin selector-end-position))))))
                  (overlay-put ov 'smalltalk-message (concat original-message (cdr (assoc 'message critique))))
                  (overlay-put ov 'help-echo (concat original-message (cdr (assoc 'message critique))))
                  (overlay-put ov 'face 'literate-smalltalk-correction-face)))
              critiques))
    (if (= 0 (length critiques))
      (message "Compile %s %s." result message)
      (message "Compile %s( %d critique) %s." result (length critiques) message))))
#+END_SRC
**** API request to format code
[[file:~/projects/smalltalk/pharo/src/Deprecated80/PluggableTextMorph.class.st::tree := RBParser parseMethod: source onError: \[ :msg :pos | ^ self \].][RBParser parseMethod]]
#+BEGIN_SRC elisp
(defun literate-smalltalk-format-code (code-start-point code type)
  (let ((resp (literate-smalltalk-request
               "api/FormatCode"
               :data `(("source" . ,(literate-smalltalk-encode-string code))
                         ("type" . ,type))
               :type "POST")))
    (unless (string= "success" (cdr (assoc 'status resp)))
      (when (fixnump (cdr (assoc 'pos resp)))
        (goto-char (+ code-start-point (cdr (assoc 'pos resp)))))
      (user-error "Failed to format code at %s:%s!"
             (cdr (assoc 'pos resp))
             (cdr (assoc 'msg resp))))
    (literate-smalltalk-decode-string (cdr (assoc 'source resp)))))

#+END_SRC
**** API request to complete code at position
#+BEGIN_SRC elisp
(defun literate-smalltalk-request-complete-code (class source)
  (literate-smalltalk-request "api/CompletionMethod"
                              :data `(("class" . ,(or class ""))
                                      ("source" . ,(literate-smalltalk-encode-string source)))
                              :type "POST"))
#+END_SRC

**** API request to delete a class
#+BEGIN_SRC elisp
(defun literate-smalltalk-request-delete-class (class)
  (literate-smalltalk-request
   "api/RemoveClass"
   :type "GET"
   :params `(("class" . ,class))))
#+END_SRC
**** API request to delete a class method
#+BEGIN_SRC elisp
(defun literate-smalltalk-request-delete-class-method (class method side)
  (literate-smalltalk-request
   "api/RemoveSelector"
   :params `(("class" . ,class)
             ("name" . ,method)
             ("side" . ,side))))
#+END_SRC
*** command to code format
#+BEGIN_SRC elisp
(defun literate-smalltalk-code-format-current-code-block ()
  (interactive)
  (let* ((context-info (second (org-element-context)))
         (block-arguments (third (org-babel-get-src-block-info)))
         (info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (code (plist-get context-info :value))
         (code-start-point (save-excursion
                             (goto-char (plist-get context-info :begin))
                             (forward-line)
                             (line-beginning-position)))
         (type (aif (cdr (assoc :type block-arguments))
                 it
                 (if (search "subclass: #" body)
                   'class
                   'method)))
         (formatted-code (literate-smalltalk-format-code code-start-point code type)))
    (replace-region-contents
     (plist-get context-info :begin)
     (plist-get context-info :end)
     (lambda ()
       (let* ((beg-src-line (progn (goto-char (point-min))
                                   (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))))
         (concat beg-src-line "\n"
                 formatted-code "\n"
                 "#+END_SRC\n"))))
    (message "format code done.")))
#+END_SRC


*** command to delete a class method
#+BEGIN_SRC elisp
(defun literate-smalltalk-delete-current-class-or-method ()
  (interactive)
  (let* ((context-info (second (org-element-context)))
         (info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (params (nth 2 info))
         (type (if (cdr (assq :type params))
                 (intern (cdr (assq :type params)))
                 (if (search "subclass: #" body)
                   'class
                   'method)))
         (resp (case type
                 (method
                  (literate-smalltalk-request-delete-class-method
                   (or (cdr (assq :class params))
                       (save-current-buffer
                         ;; have to switch to org buffer to access property value.
                         (pm-set-buffer (plist-get context-info :begin))
                         (org-entry-get (point) "literate-class" t)))
                   (literate-smalltalk-extract-selector (save-excursion
                                                          (goto-char (plist-get context-info :begin))
                                                          (forward-line)
                                                          (buffer-substring-no-properties
                                                           (line-beginning-position)
                                                           (line-end-position))))
                   (cdr (assq :side params))))
                 (class (literate-smalltalk-request-delete-class
                         (or (cdr (assq :class params))
                             (save-current-buffer
                               ;; have to switch to org buffer to access property value.
                               (pm-set-buffer (plist-get context-info :begin))
                               (org-entry-get (point) "literate-class" t))))))))
    (message "delete %s(%s)."
             (cdr (assoc 'status resp))
             (cdr (assoc 'message resp)))))
#+END_SRC

*** code completion with company mode
**** entry point
#+BEGIN_SRC elisp
(defun literate-smalltalk-completion-candidates ()
  (let* ((region (literate-smalltalk-current-symbol-region))
         (block-info (second (org-element-context)))
         (code-start-point (save-excursion
                             (goto-char (plist-get block-info :begin))
                             (forward-line)
                             (line-beginning-position)))
         (code (buffer-substring-no-properties code-start-point (point)))
         (resp (literate-smalltalk-request-complete-code
                (or (cdr (assq :class block-info))
                    (save-current-buffer
                      ;; have to switch to org buffer to access property value.
                      (pm-set-buffer (plist-get block-info :begin))
                      (org-entry-get (point) "literate-class" t)))
                code)))
    (if (string= "success" (cdr (assoc 'status resp)))
      (mapcar #'identity (cdr (assoc 'entities resp)))
      ;; we have to add a timer to report exception because in a company completion, it will use `unwind-protect'
      ;; and make our error message silient.
      (run-at-time "1 sec" nil
                   #'(lambda ()
                       (message "Fatal in pharo:%s"
                                (cdr (assoc 'message (request-response-data literate-smalltalk-last-response))))))
      nil)))
#+END_SRC
**** entry point for company mode
#+BEGIN_SRC elisp
(defun company-literate-smalltalk-code (command &optional arg &rest ignored)
  "`company-mode' completion backend for literate-smalltalk-code."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-literate-smalltalk-code))
    (prefix (literate-smalltalk-current-symbol-at-point))
    (candidates (literate-smalltalk-completion-candidates))))
(define-key literate-smalltalk-code-mode-map [(meta ?/)] 'company-literate-smalltalk-code)
(define-key literate-smalltalk-code-mode-map (kbd "TAB") 'company-literate-smalltalk-code)
#+END_SRC
*** Pharo
**** compile class
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiCompileClass: req

	| receiver evaluationContext status |
	status := #success.

	receiver := interactionModel doItReceiver.
	evaluationContext := interactionModel doItContext.

	[
	receiver class compiler
		source: (req at: #code);
		context: evaluationContext;
		receiver: receiver;
		requestor: nil;
		"As it is a remote request, we allow compiler handle messages such as exceptions"
			evaluate ]
		on: Error
		do: [ :e |
			^ {
				  (#status -> #failed).
				  (#message -> e asString) } asDictionary ].
	^ { (#status -> status) } asDictionary
#+END_SRC
**** remove a class
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiRemoveClass: req

	| className class |
	className := req at: #class.
	class := Smalltalk at: className asSymbol ifAbsent: nil.
	class ifNil: [
		^ {
			  (#status -> #failed).
			  (#message -> 'class Not Found') } asDictionary ].
	class removeFromSystem.
	^ {
		  (#status -> #success).
		  (#message -> '') } asDictionary
#+END_SRC
**** compile method
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiCompileMethod: req

	| className cat source side class status selector critiques message |
	className := req at: #class.
	cat := req at: #category.
	source := req at: #source.
	side := req at: #side.
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	status := #success.
	critiques := ''.
	selector := ''.
	message := ''.
	[
	selector := class compile: source classified: cat.
	critiques := (class >> selector) critiques collect: [ :critique |
		             | anchor first last |
		             anchor := critique sourceAnchor interval.
		             first := anchor ifNotNil: [ anchor first ].
		             last := anchor ifNotNil: [ anchor last ].
		             {
			             (#message -> critique asString).
			             (#first -> first).
			             (#last -> last) } asDictionary ] ]
		on: SyntaxErrorNotification , OCAbortCompilation , OCSemanticError , OCSemanticWarning
			, ReparseAfterSourceEditing
		do: [ :ex |
			message := ex asString.
			status := ex className ].
	^ {
		  (#status -> status).
		  (#message -> message).
		  (#selector -> selector).
		  (#critiques -> critiques) } asDictionary
#+END_SRC
**** remove a method
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiRemoveSelector: req

	| className methodName side class status message |
	className := req at: #class.
	methodName := req at: #name.
	side := req at: #side.
	class := Smalltalk at: className asSymbol.
	class := side = #class
		         ifTrue: [ class class ]
		         ifFalse: [ class ].
	status := #success.
	message := ''.
	[ class removeSelector: methodName asSymbol ]
		on: Exception
		do: [ :ex |
			message := ex asString.
			status := ex className ].
	^ {
		  (#status -> status).
		  (#message -> message) } asDictionary
#+END_SRC
**** format code
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiFormatCode: req

	| source type tree errBlock |
	source := req at: #source.
	type := req at: #type.
	errBlock := [ :msg :pos |
	            ^ {
		              (#status -> #failed).
		              (#msg -> msg).
		              (#pos -> pos) } asDictionary ].
	tree := type = 'method'
		        ifTrue: [ RBParser parseMethod: source onError: errBlock ]
		        ifFalse: [ RBParser parseExpression: source onError: errBlock ].
	^ {
		  (#status -> #success).
		  (#source -> tree formattedCode) } asDictionary
#+END_SRC
**** completion
#+BEGIN_SRC smalltalk :side class :cat "compiling api"
apiCompletionMethod: req

	| className source class context entities |
	className := req at: #class.
	source := req at: #source.
	class := Smalltalk at:
		         (className ifEmpty: [ #GTPlayground ] ifNotEmpty: [ className asSymbol ]).
	context := CompletionContext
		           engine: CompletionEngine new
		           class: class
		           source: source
		           position: source size.
	entities := context entries collect: [ :each | each contents ].
	^ {
		  (#status -> #success).
		  (#entities -> entities) } asDictionary
#+END_SRC
* Code navigation
The code navigation in pharo is straight-forward, there are only two concepts to lookup, a Class or a method.
** search a pattern in a buffer and return its position
Please note that we will use a lazy way to open a literate source file to save our memory.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-libraries-literate-path "~/Pharo/literate/")
(defun literate-smalltalk-search-pattern (pattern)
  (save-restriction
    (loop for buf-or-file in (cons (current-buffer)
                                   (directory-files literate-smalltalk-libraries-literate-path t ".org$"))
          for buf = (if (bufferp buf-or-file)
                      buf-or-file
                      (find-file-noselect buf-or-file))
          do (with-current-buffer buf
               (save-excursion
                 (goto-char (point-min))
                 (when (re-search-forward pattern nil t)
                   (goto-char (line-beginning-position))
                   (org-ensure-point-visible)
                   (return (list (current-buffer) (point)))))))))
#+END_SRC
** find definition of class in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-class-definition (class-name)
  (literate-smalltalk-search-pattern (format "subclass: #%s" class-name)))
#+END_SRC
** find definition of a class method in org files
Please note that we will use a lazy way to open a literate source file to save our memory.
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-method-definition (class-name method-name)
  (or (loop for buf-or-file in (cons (current-buffer)
                                     (directory-files literate-smalltalk-libraries-literate-path t ".org$"))
            for buf = (if (bufferp buf-or-file)
                        buf-or-file
                        (find-file-noselect buf-or-file))
            do (with-current-buffer buf
                 (save-excursion
                   (goto-char (point-min))
                   (pm-set-buffer (point))
                   (let (start end)
                     (if (re-search-forward (concat "#\\+PROPERTY:\\s+literate-class\\s+" class-name) nil t)
                       (setf start (point-min)
                             end (point-max))
                       (goto-char (point-min))
                       (when (re-search-forward (format ":literate-class:\s+%s" class-name) nil t)
                         (re-search-backward "^\\*")
                         (let ((block-info (second (org-element-context))))
                           (when (re-search-forward (concat "^\s*" method-name) (plist-get block-info :end) t)
                             (goto-char (line-beginning-position))
                             (org-ensure-point-visible)
                             (return (list (current-buffer) (point)))))))))))
      (literate-smalltalk-search-pattern (format ":class %s.*[\n\r]%s" class-name method-name))))
#+END_SRC
** get method name from method codes
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-name-from-source (source)
  (let* ((first-line (first (split-string body "[\n\r]+" t nil)))
         (items (split-string first-line "[ \t]+" t "[ \t]+")))
    (if (= 1 (length items))
      (first items)
      (with-temp-buffer
        (loop for item in items
              if (search ":" item)
                do (insert item))
        (buffer-string)))))
#+END_SRC
** basic idea
We will try to use [[http://geoff.greer.fm/ag/][silver searcher]] as the xref backend to search.
#+BEGIN_SRC elisp
(defun literate-smalltalk-xref-backend ()
  'xref-st)

(defun install-literate-smalltalk-xref-backend ()
  (make-local-variable 'xref-backend-functions)
  (setf xref-backend-functions '(literate-smalltalk-xref-backend)))
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-xref-backend)
#+END_SRC
** xref interfaces
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-identifier-at-point ((_backend (eql xref-st)))
  (literate-smalltalk-current-symbol-at-point))

(cl-defmethod xref-backend-definitions ((_backend (eql xref-st)) symbol)
  (literate-smalltalk--xref-find-definitions symbol))
#+END_SRC
** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk--xref-find-definitions (name)
  (interactive)
  (let* ((class? (<= ?A (aref name 0) ?Z))
         (class-name (unless class?
                       (literate-smalltalk-previous-symbol-at-point)))
         (buf-pos (if class?
                    (literate-smalltalk-find-class-definition name)
                    (literate-smalltalk-find-method-definition class-name name))))
    (when buf-pos
      (list (xref-make (if class?
                         name
                         (concat class-name ">>" name))
                       (xref-make-buffer-location (first buf-pos)
                                                (second buf-pos)))))))
#+END_SRC
** browse class in Pharo
*** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-browse-class ()
  (interactive)
  (let ((class-name (literate-smalltalk-current-symbol-at-point)))
    (literate-smalltalk-request "api/BrowseClass" :params `(("class" . ,class-name)))))
#+END_SRC

*** Pharo
#+BEGIN_SRC smalltalk :side class :cat "pharo api"
apiBrowseClass: req

	| className class |
	className := req
		             at: #class
		             ifAbsent: [
		             self abortReq: req status: 'error' message: 'No class name is specified.' ].
	class := Smalltalk at: className asSymbol.
	Smalltalk tools browser openOnClass: class.
	self bringToFront.
	^ {
		  (#status -> #success).
		  (#message -> 'Opend in Pharo') } asDictionary
#+END_SRC
** browse implementors in Pharo
*** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-browse-implementors ()
  (interactive)
  (let ((name (literate-smalltalk-current-symbol-at-point)))
    (literate-smalltalk-request "api/BrowseImplementors" :params `(("name" . ,name)))))
#+END_SRC
*** Pharo
#+BEGIN_SRC smalltalk :side class :cat "pharo api"
apiBrowseImplementors: req

	| methodName |
	methodName := req
		              at: #name
		              ifAbsent: [
		              self abortReq: req status: 'error' message: 'No name is specified.' ].
	SystemNavigation default browseAllImplementorsOf: methodName asSymbol.
	self bringToFront.
	^ {
		  (#status -> #success).
		  (#message -> 'Opend in Pharo') } asDictionary
#+END_SRC
* Update source
#+BEGIN_SRC elisp
(defun literate-smalltalk-update-source ()
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (params (nth 2 info))
         (block-info (second (org-element-context)))
         (type (if (cdr (assq :type params))
                 (intern (cdr (assq :type params)))
                 (if (search "subclass: #" body)
                   'class
                   'method)))
         (code (case type
                 (method
                     (literate-smalltalk-method-source
                      (or (cdr (assq :class params))
                          (save-current-buffer
                            ;; have to switch to org buffer to access property value.
                            (pm-set-buffer (plist-get block-info :begin))
                            (org-entry-get (point) "literate-class" t)))
                      (literate-smalltalk-method-name-from-source body)
                      (cdr (assq :side params))))
                 (class
                  (literate-smalltalk-class
                   (or (cdr (assq :name params))
                       (save-current-buffer
                         ;; have to switch to org buffer to access property value.
                         (pm-set-buffer (plist-get block-info :begin))
                         (org-entry-get (point) "literate-class" t)))))
                 (t
                  (user-error "Unknown supported type %s" type))))
         (body (and code (literate-smalltalk-decode-string code))))
    (when body
      (let ((block-info (second (org-element-context))))
        (replace-region-contents (plist-get block-info :begin)
                                 (plist-get block-info :end)
                                 (lambda ()
                                   (let* ((beg-src-line (progn (goto-char (point-min))
                                                               (buffer-substring-no-properties
                                                                (line-beginning-position)
                                                                (line-end-position)))))
                                     (concat beg-src-line "\n"
                                             body "\n"
                                             "#+END_SRC\n"))))
        (message "update source done.")))))
#+END_SRC
* imports codes to org file
** Import codes of namespaces to org mode
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-to-org-section (&optional namespaces)
  (interactive)
  (let ((namespaces (or namespaces (literate-smalltalk-select-namespace))))
    (unless (listp namespaces)
      (setf namespaces (list namespaces)))
    (cl-loop with count-of-namespaces = (length namespaces)
             for index from 1
             for namespace in namespaces
             do (newline)
             (insert "* PACKAGE " namespace)
             (newline)
             (loop for class in (literate-smalltalk-classes namespace)
                   for categories-dict = (literate-smalltalk-categories class)
                   do (insert "** CLASS " class)
                      (newline)
                      (insert ":PROPERTIES:")
                      (newline)
                      (insert ":literate-class:    " class)
                      (newline)
                      (insert ":END:")
                      (newline)
                      (insert "*** CLASS DEFINITION")
                      (newline)
                      (insert "#+BEGIN_SRC smalltalk")
                      (newline)
                      (insert (literate-smalltalk-class class))
                      (newline)
                      (insert "#+END_SRC")
                      (newline)
                      (loop for side in '("class" "instance")
                            for side-symbol = (intern side)
                            do (loop for category across (cdr (assoc side-symbol categories-dict))
                                     for normalized-category = (replace-regexp-in-string
                                                                       " " "@" category)
                                     do (loop for method in (literate-smalltalk-category-methods
                                                                     class category side)
                                              for source = (literate-smalltalk-method-source
                                                                  class method side)
                                              if (not (literate-smalltalk-autogenerated-code? source))
                                              do (insert "*** METHOD "
                                                         method "                                            "
                                                                side
                                                         ":" normalized-category ":")
                                                 (newline)
                                                 (insert "#+BEGIN_SRC smalltalk"
                                                         " :class " class
                                                         " :side " side
                                                         " :cat \"" category "\"")
                                                 (newline)
                                                 (insert source)
                                                 (newline)
                                                 (insert "#+END_SRC")
                                                 (newline)
                                                 (sit-for 0)))))
             (message "namespace '%s'(%d/%d) has been added." namespace index count-of-namespaces))))
#+END_SRC
** Import codes of packages to org mode
#+BEGIN_SRC elisp
(defun literate-smalltalk-package-to-org-section (&optional packages)
  (interactive)
  (let ((packages (or packages (literate-smalltalk-select-package))))
    (unless (listp packages)
      (setf packages (list packages)))
    (cl-loop with count-of-packages = (length packages)
             for index from 1
             for package in packages
             for tags = (literate-smalltalk-package-tags package)
             for extensions = (literate-smalltalk-package-extensions package)
             do (newline)
             (insert "* PACKAGE " package)
             (newline)
             (loop for tag across tags
                   do (insert "** TAG " (cdr (assoc 'name tag)))
                      (newline)
                      (loop for class across (cdr (assoc 'classes tag))
                            for categories-dict = (literate-smalltalk-categories class)
                            do (insert "*** CLASS " class)
                               (newline)
                               (insert ":PROPERTIES:")
                               (newline)
                               (insert ":literate-class:    " class)
                               (newline)
                               (insert ":END:")
                               (newline)
                               (insert "**** CLASS DEFINITION")
                               (newline)
                               (insert "#+BEGIN_SRC smalltalk")
                               (newline)
                               (insert (literate-smalltalk-class class))
                               (newline)
                               (insert "#+END_SRC")
                               (newline)
                               (loop for side in '("class" "instance")
                                     for side-symbol = (intern side)
                                     do (loop for category across (cdr (assoc side-symbol categories-dict))
                                              for normalized-category = (replace-regexp-in-string
                                                                                " " "@" category)
                                              do (loop for method in (literate-smalltalk-category-methods
                                                                              class category side)
                                                       for source = (literate-smalltalk-method-source
                                                                             class method side)
                                                       if (not (literate-smalltalk-autogenerated-code? source))
                                                         do (insert "**** METHOD "
                                                                    method "                                            "
                                                                           side
                                                                    ":" normalized-category ":")
                                                            (newline)
                                                            (insert "#+BEGIN_SRC smalltalk"
                                                                    " :class " class
                                                                    " :side " side
                                                                    " :cat \"" category "\"")
                                                            (newline)
                                                            (insert source)
                                                            (newline)
                                                            (insert "#+END_SRC")
                                                            (newline)
                                                            (sit-for 0))))))
             (cl-loop initially (when (> (length extensions) 0)
                                  (insert "** Extensions ")
                                  (newline))
              for extension across extensions
                      do (insert "*** " (cdr (assoc 'name extension)))
                      (newline)
                      (insert "#+BEGIN_SRC smalltalk"
                              " :class " (cdr (assoc 'class extension))
                              " :side " (cdr (assoc 'side extension))
                              " :cat \"" (cdr (assoc 'category extension)) "\"")
                      (newline)
                      (insert (literate-smalltalk-decode-string (cdr (assoc 'code extension))))
                      (newline)
                      (insert "#+END_SRC")
                      (newline))
             (message "package '%s'(%d/%d) has been added." package index count-of-packages))))
#+END_SRC
* babel support
** optionally define a file extension for this language
#+BEGIN_SRC elisp
(add-to-list 'org-babel-tangle-lang-exts '("smalltalk" . "smalltalk"))
#+END_SRC
** optionally declare default header arguments
#+BEGIN_SRC elisp
(defvar org-babel-default-header-args:smalltalk '())
#+END_SRC
** Source Code Execution
*** babel entry
This is the main function which is called to evaluate a code block.

This function will evaluate the body of the source code and
return the results as emacs-lisp depending on the value of the
=:results= header argument

All header arguments specified by the user will be available in the =PARAMS= variable.
#+BEGIN_SRC elisp
(defun org-babel-execute:smalltalk (body params)
  "Execute a block of smalltalk code with org-babel.
This function is called by `org-babel-execute-src-block',
Argument BODY: the code body
Argument PARAMS: the input parameters."
  (let* ((result-params (cdr (assq :result-params params)))
         (results (literate-smalltalk-execute-code-block body params)))
    (unless (stringp results)
      (setf results (format "%s" results)))
    (decode-coding-string results 'latin-1-mac)))
#+END_SRC
*** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-code-block (body params)
  (let ((type (if (cdr (assq :type params))
                (intern (cdr (assq :type params)))
                (if (search "subclass: #" body)
                  'class
                  'method)))
        (side (cdr (assq :side params)))
        (block-info (second (org-element-context)))
        (code (literate-smalltalk-encode-string body)))
    (case type
      (code (literate-smalltalk-eval code (not (null current-prefix-arg))))
      (method
       (literate-smalltalk-compile-method
        (or (cdr (assq :class params))
            (save-current-buffer
              ;; have to switch to org buffer to access property value.
              (pm-set-buffer (plist-get block-info :begin))
              (org-entry-get (point) "literate-class" t)))
        side
        (cdr (assq :cat params))
        code block-info))
      (class
       (literate-smalltalk-compile-class body))
      (t
       (user-error "Unknown type %s" type)))))
#+END_SRC
** execute all source codes in current header
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-current-header ()
  (interactive)
  (let* ((element (org-element-at-point))
         (info (second element))
         (begin (plist-get info :begin))
         (end (plist-get info :end)))
    (if current-prefix-arg
      (setf end (point-max))
      (unless (eq 'headline (first element))
        (user-error "Please move point to a headline.")))
    (goto-char begin)
    (while (search-forward "#+BEGIN_SRC smalltalk" end t)
      (unless (search ":type code" (buffer-substring-no-properties (line-beginning-position)
                                                                   (line-end-position)))
        (org-babel-execute-src-block-maybe)))))
#+END_SRC
** execute source codes in current code block
We have to switch back to org buffer, otherwise =org-babel-execute-src-block-maybe= will report a message and
override our own compilation report.
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-current-code-block ()
  (interactive)
  (let* ((element (org-element-at-point))
         (info (second element))
         (begin (plist-get info :begin)))
    (save-excursion
      (goto-char begin)
      (pm-set-buffer (point))
      (org-babel-execute-src-block-maybe))))
#+END_SRC

* Release from pharo to local file system
#+BEGIN_SRC smalltalk :type code
{ #BaselineOfLiterateSmalltalk. #LiterateSmalltalk } do: [ :package |
	LiterateServer releaseIcebergPackage: package ]
#+END_SRC
* Test
** eval codes
:PROPERTIES:
:results:  value
:END:
#+BEGIN_SRC smalltalk :type code :results raw
| y |
y := Dictionary new.
y at: 'page' put: '2'.
y
#+END_SRC
** ban some critiques rules
#+BEGIN_SRC smalltalk :type code
{ #RBBadMessageRule. #ReBadMessageRule. #RBImplementedNotSentRule.
#ReImplementedNotSentRule. #RBUtilityMethodsRule. #ReUtilityMethodsRule.
#ReUncommonMessageSendRule } do: [ :name |
	| class |
	class := Smalltalk at: name ifAbsent: [ nil ].
	class ifNotNil: [ class enabled: false ] ]
#+END_SRC
** test
#+BEGIN_SRC smalltalk :type code
Metacello new
	baseline: 'LiterateSmalltalk';
	repository: 'filetree:///home/jingtao/projects/literate-smalltalk/';
	onConflict: [ :ex | ex allow ];
	load.
(Metacello image baseline: 'LiterateSmalltalk') list first repositories list first spec
	description
#+END_SRC
